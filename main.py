from enum import StrEnum, Enum
import dspy
from typing import Optional
from langgraph.types import Command
from typing_extensions import Literal, TypedDict, get_args
from langgraph.graph import START, END, StateGraph
from langgraph.checkpoint.memory import InMemorySaver
import random


def main():
    writer_prompt = """
    Look at state. If it's REVISION_REQUIRED, ignore your previous internal "plan" and prioritize the critiques.
    Find the entry in the critiques array that matches the current target_ref.
    Re-generate only the specific field requested, while maintaining consistency with the non-rejected fields (the "Source of Truth").
    """


def validator_agent():
    """it validates the narrative consistency"""
    pass


def transition_rewriter_agent():
    """rewrites if any dependencies of a content block became STALE"""

    # constrained rewriting, anchored in beat sheet - when scene X should be rewritten because scene X-1 changed, then scene X needs to adjusted while maintaining consistency with scene X-1 and beat sheet.
    #  If that is not possible, emit BLOCKER signal
    #    then the next step is to update the beat sheet

    """
    sample blocker control signal
    {
        status: REWRITING_FAILED,
        issue_severity: BLOCKER,
        feedback: ,
        target_scope: 
    }
    """

    pass


def summarizer_agent():
    """it summarizes for significant events, emotional shifts and open threads. Not for brevity."""

    # todo: how/when to update the state with summaries?
    pass


class STATUS(StrEnum):
    TO_BE_WRITTEN = "TO_BE_WRITTEN"  # when a new phase starts
    FEEDBACK_REQUIRED = "FEEDBACK_REQUIRED"  # writing_agent has finished
    REVISION_REQUIRED = "REVISION_REQUIRED"  # critique_agent wants improvement
    APPROVED = "APPROVED"  # critique_agent approved


class PHASE(Enum):
    BEAT_SHEET = 1

    @classmethod
    def get_highest_index(cls) -> int:
        return max([p.value for p in cls])

    @classmethod
    def get_next_phase(cls, current_phase_index: int) -> Optional["PHASE"]:
        highest_index = cls.get_highest_index()
        the_next_index = current_phase_index + 1
        if the_next_index > highest_index:
            return
        else:
            return cls(the_next_index)


class ScreenplayState(TypedDict):
    # content given by the user
    genre: str
    message: str  # the message/theme of the movie
    setting: str
    logline: str

    # content generated by the system
    beat_sheet: list[str]

    # writing metadata
    critique_feedback: Optional[str]
    # state: Literal["NOT_STARTED_YET", "IN_DRAFT", "FINISHED"]
    status: STATUS
    phase: PHASE


def orchestrator_agent(state: ScreenplayState):
    """when a phase is finished, human approval is needed to commence to the next phase"""
    # receive new draft
    #  validate json format
    #  lint-check static information; names, etc.
    #  pass to validator for narrative consistency check
    #  pass to critique agent for narrative quality check

    if state["status"] == "TO_BE_WRITTEN":
        print("orchestrator: forwarding to writer")
        return Command(goto="writer_agent")

    elif state["status"] == "FEEDBACK_REQUIRED":
        print("orchestrator: forwarding to critique")
        return Command(goto="critique_agent")

    elif state["status"] == "REVISION_REQUIRED":
        print("orchestrator: forwarding to writer")
        return Command(goto="writer_agent")

    elif state["status"] == "APPROVED":
        current_phase = state["phase"]
        next_phase = PHASE.get_next_phase(
            current_phase.value
        )  # TODO: when saving this phase info to DB, the enum needs to be stripped to a string or int. .value or .name.

        if next_phase is None:
            print("orchestrator: forwarding to END")
            return Command(goto=END)
        else:
            print("orchestrator: moving to the next phase")
            return Command(
                goto="writer_agent",
                update={"phase": next_phase, "status": "TO_BE_WRITTEN"},
            )

    return Command(goto=END)


def critique_agent(state: ScreenplayState):
    """it critiques the narrative quality"""

    """
    transitioning between phases:
    1. there can be a list phases and every time, this agent signals 'APPROVED' orchestrator can move to the next phase.
    """

    critique_simulation = random.randint(0, 1)
    if critique_simulation == 0:
        print("critique: requiring revision")
        return Command(
            goto="orchestrator_agent",
            update={
                "status": "REVISION_REQUIRED",
                "critique_feedback": "It feels too much on the nose",
            },
        )
    else:
        print("critique: approving")
        return Command(goto="orchestrator_agent", update={"status": "APPROVED"})


def writer_beat_sheet_prompt(state: ScreenplayState) -> str:
    # Use f-strings for readability
    context = (
        f"Genre: {state['genre']}\n"
        f"Message/Theme: {state['message']}\n"
        f"Logline: {state['logline']}"
    )

    if state["status"] == STATUS.REVISION_REQUIRED:
        return f"""
            {context}
                    
            Your previous beat sheet: {state['beat_sheet']}
            Critique to address: {state['critique_feedback']}

            Task: Improve the beat sheet based on the critique.
            """.strip()

    return f"""
            {context}

            Task: Write a beat sheet based on the provided genre, message, and logline.
            """.strip()


writer_prompts = {PHASE.BEAT_SHEET: writer_beat_sheet_prompt}


def writer_agent(state: ScreenplayState):
    # submit new draft
    current_phase: PHASE = state["phase"]
    prompt_func = writer_prompts[current_phase]
    prompt = prompt_func(state)
    print("writer: writing based on this prompt: {}".format(prompt))

    writer = dspy.ChainOfThought("prompt: str -> beat_sheet: list[str]")

    return Command(
        goto="orchestrator_agent",
        update={
            "status": "FEEDBACK_REQUIRED",
            # TODO: make the keys dynamic regarding which field to update.
            "beat_sheet": ["They hang out in a bar", "They are eating cookies"],
        },
    )


if __name__ == "__main__":
    graph = StateGraph(ScreenplayState)

    graph.add_node("orchestrator_agent", orchestrator_agent)  # pyrefly: ignore
    graph.add_node("critique_agent", critique_agent)  # pyrefly: ignore
    graph.add_node("writer_agent", writer_agent)  # pyrefly: ignore

    graph.add_edge(START, "orchestrator_agent")
    graph.add_edge("orchestrator_agent", END)

    starting_screenplay_state = ScreenplayState(  # pyrefly: ignore
        genre="sitcom",
        message="when is adulthood starting then?",
        logline="Two guys who are trying their best to cope with adulthood, but they were not expecting it",
        status="TO_BE_WRITTEN",
        phase=PHASE.BEAT_SHEET,
    )

    # saver = InMemorySaver()
    # compiled_graph = graph.compile(checkpointer=saver)
    compiled_graph = graph.compile()
    compiled_graph.invoke(starting_screenplay_state)
