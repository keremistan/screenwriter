import dspy
from typing import Optional
from langgraph.types import Command
from typing_extensions import Literal, TypedDict, get_args
from langgraph.graph import START, END, StateGraph
from langgraph.checkpoint.memory import InMemorySaver
import random


def main():
    writer_prompt = """
    Look at state. If it's REVISION_REQUIRED, ignore your previous internal "plan" and prioritize the critiques.
    Find the entry in the critiques array that matches the current target_ref.
    Re-generate only the specific field requested, while maintaining consistency with the non-rejected fields (the "Source of Truth").
    """


def validator_agent():
    """it validates the narrative consistency"""
    pass


def transition_rewriter_agent():
    """rewrites if any dependencies of a content block became STALE"""

    # constrained rewriting, anchored in beat sheet - when scene X should be rewritten because scene X-1 changed, then scene X needs to adjusted while maintaining consistency with scene X-1 and beat sheet.
    #  If that is not possible, emit BLOCKER signal
    #    then the next step is to update the beat sheet

    """
    sample blocker control signal
    {
        status: REWRITING_FAILED,
        issue_severity: BLOCKER,
        feedback: ,
        target_scope: 
    }
    """

    pass


def summarizer_agent():
    """it summarizes for significant events, emotional shifts and open threads. Not for brevity."""

    # todo: how/when to update the state with summaries?
    pass


STATUS = Literal[
    "TO_BE_WRITTEN",  # when a new phase starts
    "FEEDBACK_REQUIRED",  # writing_agent has finished
    "REVISION_REQUIRED",  # critique_agent wants improvement
    "APPROVED",  # critique_agent approved
]

PHASE = Literal[
    "LOGLINE",
    "BEAT_SHEET",
]

PHASE_ORDER: list[PHASE] = [
    "LOGLINE",  # starting phase
    "BEAT_SHEET",
]


class ScreenplayState(TypedDict):
    # content given by the user
    genre: str
    message: str  # the message/theme of the movie
    setting: str

    # content generated by the system
    logline: str
    beat_sheet: list[str]

    # writing metadata
    critique_feedback: Optional[str]
    # state: Literal["NOT_STARTED_YET", "IN_DRAFT", "FINISHED"]
    status: STATUS
    phase: PHASE


def _get_next_phase(current_phase) -> Optional[PHASE]:
    index_of_current_phase = PHASE_ORDER.index(current_phase)
    print("index_of_current_phase: {}".format(index_of_current_phase))
    the_next_index = (
        index_of_current_phase + 1
        if index_of_current_phase + 1 < len(PHASE_ORDER)
        else None
    )
    print("the_next_index: {}".format(the_next_index))

    if the_next_index is None:
        return
    else:
        return PHASE_ORDER[the_next_index]


def orchestrator_agent(state: ScreenplayState):
    """when a phase is finished, human approval is needed to commence to the next phase"""
    # receive new draft
    #  validate json format
    #  lint-check static information; names, etc.
    #  pass to validator for narrative consistency check
    #  pass to critique agent for narrative quality check

    if state["status"] == "TO_BE_WRITTEN":
        print("orchestrator: forwarding to writer")
        return Command(goto="writer_agent")

    elif state["status"] == "FEEDBACK_REQUIRED":
        print("orchestrator: forwarding to critique")
        return Command(goto="critique_agent")

    elif state["status"] == "REVISION_REQUIRED":
        print("orchestrator: forwarding to writer")
        return Command(goto="writer_agent")

    elif state["status"] == "APPROVED":
        current_phase = state["phase"]
        print("current phase: {}".format(current_phase))
        next_phase = _get_next_phase(current_phase)
        print("the next phase: {}".format(next_phase))

        if next_phase is None:
            print("orchestrator: forwarding to END")
            return Command(goto=END)
        else:
            print("orchestrator: moving to the next phase")
            return Command(
                goto="writer_agent",
                update={"phase": next_phase, "status": "TO_BE_WRITTEN"},
            )

    return Command(goto=END)


def critique_agent(state: ScreenplayState):
    """it critiques the narrative quality"""

    """
    transitioning between phases:
    1. there can be a list phases and every time, this agent signals 'APPROVED' orchestrator can move to the next phase.
    """

    critique_simulation = random.randint(0, 1)
    if critique_simulation == 0:
        print("critique: requiring revision")
        return Command(
            goto="orchestrator_agent", update={"status": "REVISION_REQUIRED"}
        )
    else:
        print("critique: approving")
        return Command(goto="orchestrator_agent", update={"status": "APPROVED"})


def writer_agent(state: ScreenplayState):
    # submit new draft

    print("writer: writing")

    # writer = dspy.ChainOfThought("")

    return Command(goto="orchestrator_agent", update={"status": "FEEDBACK_REQUIRED"})


if __name__ == "__main__":
    graph = StateGraph(ScreenplayState)

    graph.add_node("orchestrator_agent", orchestrator_agent)
    graph.add_node("critique_agent", critique_agent)
    graph.add_node("writer_agent", writer_agent)

    graph.add_edge(START, "orchestrator_agent")
    graph.add_edge("orchestrator_agent", END)

    starting_screenplay_state = ScreenplayState(
        genre="sitcom", status="TO_BE_WRITTEN", phase="LOGLINE"
    )

    # saver = InMemorySaver()
    # compiled_graph = graph.compile(checkpointer=saver)
    compiled_graph = graph.compile()
    compiled_graph.invoke(starting_screenplay_state)
